import os
import asyncio
import re
from aiogram import Bot, Dispatcher, F
from aiogram.filters import Command
from aiogram.types import Message, InlineKeyboardMarkup, InlineKeyboardButton, CallbackQuery
from aiogram.fsm.storage.memory import MemoryStorage
from anthropic import Anthropic
import requests
import json
from datetime import datetime
# Токены
TELEGRAM_TOKEN = os.getenv('TELEGRAM_BOT_TOKEN')
CLAUDE_API_KEY = os.getenv('CLAUDE_API_KEY')
WEEEK_TOKEN = os.getenv('WEEEK_API_TOKEN')
WEEEK_WORKSPACE_ID = os.getenv('WEEEK_WORKSPACE_ID')
WEEEK_BOARD_ID = os.getenv('WEEEK_BOARD_ID')
# Инициализация
bot = Bot(token=TELEGRAM_TOKEN)
dp = Dispatcher(storage=MemoryStorage())
claude = Anthropic(api_key=CLAUDE_API_KEY)
# Хранилище
user_messages = {}
user_tasks = {}
# === РАБОТА С WEEEK ===
def create_task_in_weeek(task_data):
    """Создаёт задачу в Weeek"""
    url = "https://api.weeek.net/public/v1/tm/tasks"
    
    headers = {
        "Authorization": f"Bearer {WEEEK_TOKEN}",
        "Content-Type": "application/json"
    }
    
    payload = {
        "name": task_data.get("title", "Без названия")[:255],
        "description": task_data.get("description", ""),
        "workspaceId": int(WEEEK_WORKSPACE_ID),
        "boardId": int(WEEEK_BOARD_ID)
    }
    
    if task_data.get("deadline"):
        payload["dueDate"] = task_data["deadline"]
    
    print(f"📤 Отправка в Weeek: {payload}")
    
    try:
        response = requests.post(url, headers=headers, json=payload, timeout=10)
        print(f"📥 Ответ Weeek: {response.status_code} - {response.text}")
        
        if response.status_code in [200, 201]:
            return response.json()
        else:
            print(f"❌ Ошибка Weeek: {response.text}")
            return None
    except Exception as e:
        print(f"❌ Исключение: {e}")
        return None
# === РАБОТА С CLAUDE (ИСПРАВЛЕННАЯ МОДЕЛЬ) ===
def analyze_with_claude(text, context="task"):
    """Анализирует текст через Claude"""
    
    if context == "task":
        prompt = f"""Ты - ассистент по управлению задачами.
Проанализируй текст пользователя и извлеки задачу.
ВАЖНО: Верни ТОЛЬКО валидный JSON без любого дополнительного текста, markdown или комментариев.
Формат ответа:
{{
  "title": "Краткое название задачи (до 50 символов)",
  "description": "Подробное описание",
  "category": "SMM",
  "priority": "Срочно",
  "deadline": null
}}
Категории: SMM, Маркетинг, Продажи, Аналитика, Личное
Приоритеты: Критично, Срочно, Важно, Можно отложить
Текст пользователя:
{text}"""
    elif context == "meeting":
        prompt = f"""Ты - ассистент по анализу планёрок.
Проанализируй транскрипцию и извлеки ВСЕ задачи.
ВАЖНО: Верни ТОЛЬКО валидный JSON.
Формат:
{{
  "tasks": [
    {{
      "title": "Название",
      "description": "Описание с цитатой",
      "category": "SMM",
      "priority": "Срочно",
      "deadline": null,
      "assignee": null
    }}
  ]
}}
Транскрипция:
{text}"""
    
    elif context == "ai_help":
        prompt = f"""Ты - AI-помощник для выполнения задач.
{text}
Дай конкретный пошаговый план действий."""
    
    try:
        message = claude.messages.create(
            model="claude-3-5-haiku-20241022",  # ← ИСПРАВЛЕНА МОДЕЛЬ!
            max_tokens=4000,
            messages=[{"role": "user", "content": prompt}]
        )
        
        response_text = message.content[0].text.strip()
        
        print(f"🤖 Claude RAW ответ: {response_text[:300]}...")
        
        if context == "ai_help":
            return response_text
        
        # Убираем markdown
        response_text = response_text.replace("```json", "")
        response_text = response_text.replace("```", "")
        response_text = response_text.strip()
        
        # Ищем JSON
        json_match = re.search(r'\{.*\}', response_text, re.DOTALL)
        
        if json_match:
            json_str = json_match.group(0)
            print(f"📦 Extracted JSON: {json_str[:200]}...")
            return json.loads(json_str)
        else:
            print(f"❌ Не найден JSON в ответе")
            return None
        
    except json.JSONDecodeError as e:
        print(f"❌ Ошибка парсинга JSON: {e}")
        print(f"Текст ответа: {response_text[:500]}")
        
        # Создаём задачу вручную
        return {
            "title": text[:50],
            "description": text,
            "category": "Личное",
            "priority": "Важно",
            "deadline": None
        }
        
    except Exception as e:
        print(f"❌ Ошибка Claude API: {e}")
        return None
# === КОМАНДЫ ===
@dp.message(Command("start"))
async def cmd_start(message: Message):
    await message.answer(
        "👋 Привет! Я твой AI-ассистент!\n\n"
        "📝 **Создание задач:**\n"
        "• Напиши текст задачи\n"
        "• Отправь голосовое\n"
        "• Отправь файл планёрки\n\n"
        "🤖 **AI-помощник:**\n"
        "• /help - помощь\n"
        "• Просто спроси!\n\n"
        "📋 /tasks - список задач"
    )
@dp.message(Command("help"))
async def cmd_help_command(message: Message):
    await message.answer(
        "🤖 **Как я работаю:**\n\n"
        "**1. Создание задачи:**\n"
        "Напиши что нужно сделать\n\n"
        "**2. Несколько сообщений:**\n"
        "Пиши подряд - я спрошу\n\n"
        "**3. Планёрка:**\n"
        "Отправь файл транскрипции\n\n"
        "**4. AI-помощник:**\n"
        "Спроси: 'Как сделать X?'"
    )
@dp.message(Command("tasks"))
async def cmd_tasks(message: Message):
    user_id = message.from_user.id
    
    if user_id not in user_tasks or not user_tasks[user_id]:
        await message.answer("📋 У тебя пока нет задач!")
        return
    
    tasks = user_tasks[user_id]
    response = f"📋 **Твои задачи ({len(tasks)}):**\n\n"
    
    for i, task in enumerate(tasks, 1):
        priority_emoji = {
            "Критично": "🔥",
            "Срочно": "🔴",
            "Важно": "🟡",
            "Можно отложить": "🟢"
        }
        emoji = priority_emoji.get(task.get('priority', ''), '📋')
        response += f"{i}. {emoji} {task['title']}\n"
    
    await message.answer(response)
# === ОБРАБОТКА ТЕКСТА ===
@dp.message(F.text & ~F.text.startswith('/'))
async def handle_text(message: Message):
    user_id = message.from_user.id
    text = message.text
    
    # AI-помощник?
    ai_triggers = ["как", "помоги", "подскажи", "что делать", "как сделать", "нужна помощь"]
    if any(trigger in text.lower() for trigger in ai_triggers):
        await handle_ai_help(message, text)
        return
    
    # Задача
    if user_id not in user_messages:
        user_messages[user_id] = []
    
    user_messages[user_id].append({
        "text": text,
        "time": datetime.now()
    })
    
    recent = [m for m in user_messages[user_id] 
              if (datetime.now() - m["time"]).total_seconds() < 60]
    
    if len(recent) > 1:
        combined = "\n".join([m["text"] for m in recent])
        
        keyboard = InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="✅ Да, одна задача", callback_data="merge_yes")],
            [InlineKeyboardButton(text="❌ Нет, отдельные", callback_data="merge_no")]
        ])
        
        await message.answer(
            f"📝 Вижу {len(recent)} сообщений за минуту.\n\n"
            f"Объединить в одну задачу?\n\n"
            f"Текст:\n{combined[:300]}{'...' if len(combined) > 300 else ''}",
            reply_markup=keyboard
        )
    else:
        await process_single_task(message, text)
# === AI-ПОМОЩНИК ===
async def handle_ai_help(message: Message, question: str):
    """AI-помощник"""
    await message.answer("🤖 Думаю...")
    
    user_id = message.from_user.id
    context = ""
    
    if user_id in user_tasks and user_tasks[user_id]:
        last_task = user_tasks[user_id][-1]
        context = f"\nКонтекст последней задачи:\n{last_task['title']}\n{last_task['description']}"
    
    full_prompt = f"{question}{context}"
    
    ai_response = analyze_with_claude(full_prompt, context="ai_help")
    
    if ai_response:
        await message.answer(f"💡 **AI-помощник:**\n\n{ai_response}")
    else:
        await message.answer("❌ Не смог обработать запрос")
# === ОБРАБОТКА ЗАДАЧИ ===
async def process_single_task(message: Message, text: str):
    """Обработка одной задачи"""
    status_msg = await message.answer("🤖 Анализирую задачу...")
    
    task_data = analyze_with_claude(text, context="task")
    
    if not task_data:
        await status_msg.edit_text("❌ Не удалось обработать. Попробуйте переформулировать.")
        return
    
    user_id = message.from_user.id
    if user_id not in user_tasks:
        user_tasks[user_id] = []
    user_tasks[user_id].append(task_data)
    
    priority_emoji = {
        "Критично": "🔥",
        "Срочно": "🔴",
        "Важно": "🟡",
        "Можно отложить": "🟢"
    }
    
    response = (
        f"{priority_emoji.get(task_data['priority'], '📋')} **{task_data['title']}**\n\n"
        f"📝 {task_data['description']}\n\n"
        f"📁 Категория: {task_data['category']}\n"
        f"⏰ Приоритет: {task_data['priority']}\n"
    )
    
    if task_data.get('deadline'):
        response += f"📅 Дедлайн: {task_data['deadline']}\n"
    
    response += "\n✅ Создать задачу в Weeek?"
    
    keyboard = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="✅ Создать в Weeek", callback_data=f"create_task")],
        [InlineKeyboardButton(text="💡 Нужна помощь", callback_data=f"help_task")],
        [InlineKeyboardButton(text="❌ Отмена", callback_data="cancel")]
    ])
    
    await status_msg.edit_text(response, reply_markup=keyboard)
# === ГОЛОСОВЫЕ ===
@dp.message(F.voice)
async def handle_voice(message: Message):
    """Обработка голосовых"""
    if message.caption:
        await message.answer("🎤 Получил расшифровку!")
        await process_single_task(message, message.caption)
    else:
        await message.answer(
            "🎤 Голосовое получено!\n\n"
            "⚠️ Telegram не расшифровал.\n\n"
            "Попробуй:\n"
            "1. Переслать @voicy_bot\n"
            "2. Скопировать текст\n"
            "3. Прислать мне"
        )
# === ДОКУМЕНТЫ ===
@dp.message(F.document)
async def handle_document(message: Message):
    """Обработка файлов"""
    doc = message.document
    
    if not doc.file_name.endswith(('.txt', '.vtt', '.srt')):
        await message.answer("❌ Только .txt, .vtt, .srt")
        return
    
    status_msg = await message.answer("📄 Анализирую планёрку...")
    
    try:
        file = await bot.get_file(doc.file_id)
        file_content = await bot.download_file(file.file_path)
        text = file_content.read().decode('utf-8')
        
        await status_msg.edit_text("🤖 Claude анализирует...")
        
        result = analyze_with_claude(text, context="meeting")
        
        if not result or 'tasks' not in result:
            await status_msg.edit_text("❌ Не удалось извлечь задачи")
            return
        
        tasks = result['tasks']
        
        user_id = message.from_user.id
        if user_id not in user_tasks:
            user_tasks[user_id] = []
        user_tasks[user_id].extend(tasks)
        
        response = f"✅ Анализ завершён!\n\n📊 **Найдено задач: {len(tasks)}**\n\n"
        
        for i, task in enumerate(tasks, 1):
            priority_emoji = {
                "Критично": "🔥",
                "Срочно": "🔴",
                "Важно": "🟡",
                "Можно отложить": "🟢"
            }
            emoji = priority_emoji.get(task['priority'], '📋')
            response += f"{i}. {emoji} [{task['category']}] {task['title']}\n"
        
        response += "\n✅ Создать все задачи?"
        
        keyboard = InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="✅ Создать все", callback_data=f"create_all")],
            [InlineKeyboardButton(text="📋 Показать детали", callback_data=f"show_details")],
            [InlineKeyboardButton(text="❌ Отмена", callback_data="cancel")]
        ])
        
        await status_msg.edit_text(response, reply_markup=keyboard)
        
    except Exception as e:
        await status_msg.edit_text(f"❌ Ошибка: {str(e)}")
        print(f"Ошибка документа: {e}")
# === КНОПКИ ===
@dp.callback_query(F.data == "merge_yes")
async def handle_merge_yes(callback: CallbackQuery):
    await callback.answer()
    
    user_id = callback.from_user.id
    recent = [m for m in user_messages.get(user_id, []) 
              if (datetime.now() - m["time"]).total_seconds() < 60]
    
    combined_text = "\n".join([m["text"] for m in recent])
    
    await callback.message.edit_text("🤖 Объединяю...")
    await process_single_task(callback.message, combined_text)
    
    user_messages[user_id] = []
@dp.callback_query(F.data == "merge_no")
async def handle_merge_no(callback: CallbackQuery):
    await callback.answer()
    await callback.message.edit_text("✅ Хорошо")
@dp.callback_query(F.data == "create_task")
async def handle_create_task(callback: CallbackQuery):
    await callback.answer()
    
    user_id = callback.from_user.id
    
    if user_id not in user_tasks or not user_tasks[user_id]:
        await callback.message.edit_text("❌ Задача не найдена")
        return
    
    task_data = user_tasks[user_id][-1]
    
    await callback.message.edit_text("🤖 Создаю в Weeek...")
    
    result = create_task_in_weeek(task_data)
    
    if result:
        await callback.message.edit_text(
            f"🎉 **Задача создана!**\n\n"
            f"📋 {task_data['title']}\n\n"
            f"📊 Открыть:\n"
            f"https://app.weeek.net/ws/{WEEEK_WORKSPACE_ID}/project/1/board/{WEEEK_BOARD_ID}"
        )
    else:
        await callback.message.edit_text(
            f"❌ Ошибка создания\n\n"
            f"Проверьте:\n"
            f"• API токен Weeek\n"
            f"• ID пространства\n"
            f"• ID доски"
        )
@dp.callback_query(F.data == "create_all")
async def handle_create_all(callback: CallbackQuery):
    await callback.answer()
    
    user_id = callback.from_user.id
    
    if user_id not in user_tasks or not user_tasks[user_id]:
        await callback.message.edit_text("❌ Задачи не найдены")
        return
    
    tasks = user_tasks[user_id]
    
    await callback.message.edit_text(f"🤖 Создаю {len(tasks)} задач...")
    
    created = 0
    failed = 0
    
    for task in tasks:
        result = create_task_in_weeek(task)
        if result:
            created += 1
        else:
            failed += 1
    
    await callback.message.edit_text(
        f"🎉 **Готово!**\n\n"
        f"✅ Создано: {created}\n"
        f"❌ Ошибок: {failed}\n\n"
        f"📊 Открыть:\n"
        f"https://app.weeek.net/ws/{WEEEK_WORKSPACE_ID}/project/1/board/{WEEEK_BOARD_ID}"
    )
@dp.callback_query(F.data == "help_task")
async def handle_help_task(callback: CallbackQuery):
    await callback.answer()
    
    user_id = callback.from_user.id
    
    if user_id not in user_tasks or not user_tasks[user_id]:
        await callback.message.edit_text("❌ Задача не найдена")
        return
    
    task = user_tasks[user_id][-1]
    
    await callback.message.edit_text("🤖 Думаю...")
    
    prompt = f"Помоги выполнить:\n\n{task['title']}\n\n{task['description']}\n\nДай план действий"
    
    ai_response = analyze_with_claude(prompt, context="ai_help")
    
    if ai_response:
        keyboard = InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="✅ Создать в Weeek", callback_data="create_task")],
            [InlineKeyboardButton(text="❌ Отмена", callback_data="cancel")]
        ])
        
        await callback.message.edit_text(
            f"💡 **AI-помощник:**\n\n{ai_response}",
            reply_markup=keyboard
        )
    else:
        await callback.message.edit_text("❌ Не смог помочь")
@dp.callback_query(F.data == "show_details")
async def handle_show_details(callback: CallbackQuery):
    await callback.answer()
    
    user_id = callback.from_user.id
    
    if user_id not in user_tasks or not user_tasks[user_id]:
        await callback.message.edit_text("❌ Задачи не найдены")
        return
    
    tasks = user_tasks[user_id]
    response = f"📋 **Детали ({len(tasks)}):**\n\n"
    
    for i, task in enumerate(tasks, 1):
        response += f"{i}. **{task['title']}**\n"
        response += f"   📝 {task['description'][:100]}...\n"
        response += f"   📁 {task['category']} | ⏰ {task['priority']}\n\n"
    
    keyboard = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="✅ Создать все", callback_data="create_all")],
        [InlineKeyboardButton(text="❌ Отмена", callback_data="cancel")]
    ])
    
    await callback.message.edit_text(response, reply_markup=keyboard)
@dp.callback_query(F.data == "cancel")
async def handle_cancel(callback: CallbackQuery):
    await callback.answer()
    await callback.message.edit_text("❌ Отменено")
# === ЗАПУСК ===
async def main():
    print("=" * 50)
    print("🤖 AI-АССИСТЕНТ ЗАПУЩЕН!")
    print("=" * 50)
    print(f"✅ Telegram: {'OK' if TELEGRAM_TOKEN else '❌ НЕТ'}")
    print(f"✅ Claude: {'OK' if CLAUDE_API_KEY else '❌ НЕТ'}")
    print(f"✅ Weeek: {'OK' if WEEEK_TOKEN else '❌ НЕТ'}")
    print(f"✅ Workspace: {WEEEK_WORKSPACE_ID}")
    print(f"✅ Board: {WEEEK_BOARD_ID}")
    print(f"✅ Model: claude-3-5-haiku-20241022")
    print("=" * 50)
    
    await dp.start_polling(bot)
if __name__ == "__main__":
    asyncio.run(main())